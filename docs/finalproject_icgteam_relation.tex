\documentclass[a4paper, 11pt, titlepage]{report}	
\usepackage[T1]{fontenc}			% codifica dei font
\usepackage[utf8]{inputenc}			% lettere accentate da tastiera
\usepackage{gensymb}
\usepackage[italian]{babel}			% lingua del documento
\usepackage{lipsum}					% genera testo fittizio
\usepackage{url}					% per scrivere gli indirizzi Internet
\usepackage{geometry}
\usepackage[nouppercase]{frontespizio}	% suftesi or nouppercase
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xcolor, listings}
\usepackage{multirow}
\usepackage[colorlinks]{hyperref}
\usepackage[square,sort,comma,numbers]{natbib}
\usepackage{titlesec}

\geometry{a4paper, top=2cm, bottom=2cm, left=2.5cm, right=2.5cm, heightrounded, bindingoffset=5mm}

\pagestyle{headings}

\linespread{1.25}

\begin{document}

\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{0pt}{10pt}

\hypersetup{
	linkcolor=black,
	citecolor=black,
	urlcolor=black
}

\title{
	Interactive Graphics\\
	\large Final Project
}
\author{Nicola Iommazzo 1693395\\
		Alessandro Basciani 1675251\\
		Matteo Silvestri 1774987\\ }
\date{}
\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%	\textbf{GRASSETTO}
%	\texttt{MACCHINA DA SCRIVERE}
%	\textit{CORSIVO}
%	\emph{EMPATIZZATO}
%	'\\' per andare a capo
%	\lipsum per far comparire testo in latino come segnaposto
%
%%%%%%%%%%%

%1 page - M
\chapter{Introduction}
    This document will briefly explain the realization of the final project regarding the Interactive Graphics course. Our team decided to create a game in which the user controls a vehicle and has to totalize the maximum score by running over pedestrians in a city in the minimum amount of time.

 	\section{Libraries}
 		\par For this project we choose to use two different kind of libraries: the first one in order to handle the graphic part, and other one in order to handle collisions between objects. When we add an object inside our project (like a car or a palace) at first we will add it in our \textbf{Three.js Scene} in order to handle the position of the mesh, and after we will add it in our \textbf{Cannon.js World} in order to handle the collisions. Below we will generally explain how we used them, and their role in our project. 
	 	\subsection{Three.js}
		    \par The \textbf{Three.js} library \cite{threejsdocs} allows the creation of accelerated 3D animations using the JavaScript language as part a of a website, without relying on proprietary browser plugins. This is possible due to the advent of WebGL.
		    High-level libraries as Three.js make it possible to author complex 3D computer animations that display in the browser without the effort required for a traditional standalone application or a plugin.
		    In our project we use this library to handle all the object inside the scene, their position, the lights and the shadows of the whole game.
		\subsection{Cannon.js}
		    \par The \textbf{Cannon.js} library \cite{cannonjsdocs} is an open source library used for handle the physics engine inside our project. For physics engine we mean for example the engine that handle collisions between two or more objects. This library provides a lot of methods and classes to handle these kind of situations. All the project parts that use the Cannon.js library will be shortly explained in the related sections.

%1 page - B
\chapter{Presentation Layer}
	\par The presentation layer of the project is composed of two \emph{html} files. The first file that appears is \textbf{index.html}. In this file we explained how to play the game. The second file is \textbf{game.html}, where are explained the controls of the game and the game itself. \\
	\par In the index file are initialized a render, a scene and a point of light, all implemented throught the \textbf{Three.js} library. The objective of this page is to let the user know the scope of the game. The texts are displayed on the canvas thanks to multiple \textbf{TextGeometry}.
	The style of the text is implemented with a \emph{json} file in the directory \emph{font}.
	In this directory are available a lot of text fonts: we decided to use the \emph{serif bold}. We defined the function \textbf{addText()} for adding the text to the canvas. It requires 3 parameters: the string we want to print on the canvas, the font of the text and the vertical offset at which the text will placed. The default position is centered in the middle of the page. To do this we have initialized a 3D-vector and set its components to the maximum value of the TextGeoemtry bounding box, less the minimum one, all divided two. In this way we have placed the textGeometry in the center of the page.
	Then we created the material (together with the aspect and the color) for the TextGemoetry through the function \textbf{MeshPhongMaterial}, and finally we obtained the Mesh combining geometry and material. \\
	All these features are implemented in the script tag, while in the html tag we implemented the href with the link of the game appearing with the play icon. \\
	\par The second \emph{html} file is the \textbf{game.html}, in this file we import all the library that use in the project. In the html tag we inserted the text explaining the controls of the game and there is also a small portion of \emph{css} code, where we choose the color and the style of the page. Moreover in this file we load the external script \textbf{game.js} that will run the game itself. To start the game we click anywhere on the page and subsequently the countdown starts. 

%2 page - N
\chapter{Game components}
	\par The game world is composed by many objects, of different types and different geometries. 
	We specify that each object of the \emph{threejs scene} is created starting from a \textbf{Geometry} with a particular shape and a \textbf{Material}: combining these two elements we can form the \textbf{Mesh} and add it to the \textbf{Scene}. \\
	The geometries can be placed as pleasure in the euclidean space with simple transformation like traslations, rotations and scaling. The choice of the material is done between \emph{BaseLambertMesh} and \emph{BasePhongMaterial}: since the we want a better projection of the shadows on the other element, we adopted the \emph{BasePhongMaterial} option for the most cases.
	\par Moreover in order to make the elements collide each other we have also created \emph{cannonjs bodies}. The procedure is quite similar to the first one: at first is created the \textbf{Material} and the \textbf{Shape}, then we create the object \textbf{Body} starting from the previous ones, at the end the body object is added to the \textbf{World}.
	The elements of the whole game can be grouped as the following: 
	\begin{itemize}
		\setlength\itemsep{0.25em}
		\item Vehicles
		\item Ground plane
		\item World limits
		\item City sidewalks
		\item City lamps
		\item City palaces
	\end{itemize}  
	\section{Vehicle}
		\par The vehicle is implemented both in the \emph{threejs scene} and in the \emph{cannonjs world}. From the point of view of Three.js it is a scene loaded through the \textbf{GLTFLoader} from an external source \cite{vehiclesite}, at first scaled to adapt its dimensions to our project and then added to the scene. \\
		Much more different is the vehicle body implementation in the cannon.js world. In fact it is a \textbf{RaycastVehicle} object with a base chassis, a top chassis and four wheels. All the single bodies are kept together thanks to the constraint objects available from the cannon.js library. Since all the bodies that belongs to the vehicle has a positive mass they are subjected to the gravity force and will fall toward the ground.
	\section{City Buildings}
		\par The \textbf{ground mesh} is realized through a \emph{PlaneGeometry} object oriented towards the positive $y$ axis. There is also a ground in the \emph{cannonjs world} so that each body having a positive mass will fall towards a solid ground. For this reason the ground body has a mass equals to $0$.
		\par As for the ground plane, the \textbf{world limits} are \emph{PlaneGeometry} objects the but at first they are moved to the world edge and then rotated towards the center of the euclidean space. Since we want a single mesh representing the four world limits meshes, we merge them into a single geometry through the \emph{merge()} method, and finally we create a mesh from it. \\
		Ground limits are also implemented in the \emph{cannonjs world} in order to block the vehicle and do not let go the vehicle beyond the city edges. All these bodies are object separated and not unified as done for the meshes.
		\par The \textbf{palaces} and the \textbf{sidewalks} meshes are created starting from a particular \emph{base building} structure (see \emph{js/CityBuildings.js}). All these elements are \emph{BoxGeometry}, but for performance reasons all these boxes have the bottom face missing (the bottom face is never shown in the game because it overlaps with the ground). Moreover the texture of the \emph{faceVertexUvs} components relative to top face of the palaces are set to zero. This means that the palaces textures are not applied to the top face. As explained for the ground limits also these meshes are merged together, and finally created the final meshes of palaces and sidewalks.\\
		Palaces and sidewalks have also bodies in the cannon.js world. They are \emph{Box} bodies 
		with a mass equals to zero so that they are not subjected to the world forces of the cannon world.
		\par The last elements of the city are the \textbf{lamps}. In the three.js scene they are composed by the head, the pole and the base. All of them are \emph{BoxGeometry} from which we created meshes. There are 4 lamps for each sidewalk block and the procedure is the same for all of them.

%1 page - B
\chapter{Hierachical Model}
	\par The hierachical model allows us to create, in our specific case, the \textbf{NiceDude objects}. Generally there are two methods to create a hierachical model: in the first one we use a graph model, in the second one we use a tree model.
	For our project we implemented the NiceDude hierarchical model through the tree representation. In this model each component of the model is expressed by a node. Each node has exactly one parent node and can have one or more children nodes. The parent of all nodes is called root node and has no parent node, indeed the node with no children is called leaf.
 
	\section{The NiceDude hierarchical model}
		The NiceDude class is implemented in the \emph{NiceDude.js} file. Since we decided to implement our hierarchical model as a tree model we create a group object through a library function of Three.js. Subsequently we create the head, body, neck, left and right shoulders, left and right arms, left and right legs, left and right shoes. The head is the first object of the group and will be our root node. The following picture will explain the resulting structure of the hierarchical model we built.
		%The neck is connected to the head as a child, the body is connected at the neck, the left shoulder is connected at the body, the right shoulder is connected at body,the left arm is connected at the left shoulder, the right arm is connected at the right shoulder,the left leg is connected at the body, the right leg is connected at the body, the left shoe is connected at the left leg and the right shoes is connected at the right leg. 
		\begin{figure}[h!]
			\centering
			\includegraphics[width=0.7\textwidth]{images/NiceDudeModel}
			\caption{NiceDude hierarchical model implementation}
		\end{figure}
		All the components have a function that build that specific part of the NiceDude by setting geometries, materials, meshes and placing the objects in a particular point of the space. All the material parts are \textbf{MeshBasicMaterial} taken from the Three.js library.

%1 page - B
\chapter{Textures}
	The textures in this project are used to customize the sidewalks, the palaces, the background, the ground, the lamps lights and the city limits. All the texture are taken from sites \cite{texturesites} that offers texture images for free. To load the texture image in the game we have used the loader \textbf{THREE.TextureLoader()} available in the \emph{Three.js} library. With the \emph{load()} method of the loader, we selected the precise texture we would import into the project. To finally add the texture to a material we specify the texture object as the \emph{map} component of the material. All the textures have been implement following the just described process. The texture related to the city building can be found in the \emph{js/CityBuildings.js} file, instead the background texture is in the \emph{main.js} file.
 
	\section{City buildings textures}
		The city is composed by lots of component, but the elements customized with a texture are: palaces, ground, sidewalks, lamps lights and the city limits. We loaded a texture image for all components. Each texture is load in the same way, but what changes are the setting of the textures. Here we briefly analyze all of them. 
		\begin{itemize}
			\item The \textbf{palaces} are represented by a plot that depicts windows. For these building is not necessary any customization of the texture, it is simply loaded and applied to the mesh.			
			\item The \textbf{ground} is represented by a plot. The texture is \emph{repeated} to infinity on the vertical and horizontal axis. This has been possible thanks to the two variables for texture objects (\emph{wrapS} and \emph{wrapT}) in the \textbf{Three.js} library. We can exploit them together with the \emph{repeat} variable to say that we want the texture will repeat itself until covering the whole ground mesh.
			\item The \textbf{sidewalks} texture is simply loaded and applied to the mesh with no customization needed.
			\item The \textbf{lamps lights} are represented by a texture too. The material is build through to the \emph{PointsMaterial} function. For this texture we specify that the size variable should be 8 and the variable transparent should be true. This will let the lamps lights texture to be transparent so that we can see what there is behind it and will not cover other objects.
			\item The \textbf{city limits} are composed by four plane geometry. So we load the same texture to each of that planes. For these textures we want that they should not reflect the lights of the scene so we set the \emph{shininess} variable to zero. Morover, as for the ground texture, we want that the texture will repeat itself for all the plane dimension, so we set properly the \emph{wrapS, wrapT} and \emph{repeat} variables. 
		\end{itemize}

 	\section{Background scene}
		\par The \textbf{background} is customized by applying a texture to the \emph{background} variable of the three.js scene. Differently from the 2D textures, now we have to apply a texture to the whole 3D scene. For this reason we use the \emph{CubeTextureLoader()} loader obtaining a cube texture. In this case we do not need anymore just one image, but we need three or six images (depending on the implementation) that combined together will compose the 3D background. \\
		To select the source images we used the \emph{.setPath()} and \emph{load()} methods of the loader object. For this project we chose a background representing the Mars \cite{backgroundsite} ground.

%1 page - M
\chapter{Lights And Shadows}
    \par In this part of the documentation we talk about the handling of the \textbf{lights and shadows} in our project, below we will explain our general approach for all the objects inside the scene. 
 
	\section{General Approach}
   		\par First of all we choose which kind of light to use: \emph{DirectionaLight} or \emph{Spotlight}. The first one is a light that gets emitted in a specific direction. This light will behave as it is infinitely far away and the rays produced from it are all parallel each others. The common use case for this is to simulate daylight. The other one light gets emitted from a single point in one direction, along a cone that increases in size the further from the light it gets.
   		\par For our project we chose the \textbf{Spotlight}, because with this we can create in the simpliest way the objects shadows in our Three.js scene. After the initialization of the Spotlight we set two different parameter. One to set the position of the cone light and another one to set the cast shadows flag. This flag is use to cast or not the shadows. \\
   		\par The next step is to set the shadows inside our world, for do this we needed less time than expected. We set to true the \textbf{castShadow} and the \textbf{receiveShadow} flags of the objects of the project depending on their role in the game. By default both of the flags are false. We had to set to true the \emph{castShadow} flag for all those objects that are hit by the light, in this way we let those objects to create the shadows. The \emph{receiveShadow} flag is responsible of the rendering of the shadows on its mesh. For this reason it is enabled only for those objects that receive shadows, like sidewalks and buildings.

%1 page - N
\chapter{User Interaction}
	\par The project is capable to interact with the user in multiple ways. \\
	Starting from the \emph{index.html} the user has to press the play button in order to move to the game page. In the first page is described the objective of the game thanks to a \emph{TextGeometry} painted on the canvas (see the chapter on the Presentation Layer). Here is implemented an handler for the event \emph{document.mousemove} \cite{jsevents} so that when the user moves the mouse cursor on the screen, the values of the \emph{camera.position} related to the \emph{threejs scene} change. We focus on the fact that this movement cannot be defined as a real animation of the text object since the mesh is not really moving in the space, but it is only the point of view of the camera that changes its position. \\
	By clicking on the play button the user moves to the game page where are described the commands to play the game. When the user clicks on the screen the instructions disappear, the game starts and the \emph{render()} function starts to update all the elements of the scene on the canvas.\\
	\section{Vehicle Controller}
		\par All the commands that refers to the vehicle movement are implemented in the file \emph{js/Controls.js}. In this script there is a function handler for the events \emph{document.onkeydown} and \emph{document.onkeyup} \cite{jsevents}. So when the user presses or releases a button on the keyboard it is created an event that is intercepted by the function handler. Each button key is associated to a different keycode, in this way we can determine which button is pressed and differentiate the behaviour of the game. The handler modify the \emph{keyDown} array of 320 boolean values, each one referring to a different key on the keyboard, setting to \emph{true} the \emph{i-th} cell if the button with keycode \emph{i} is pressed, otherwise it is set to \emph{false}.
		\par At each cycle of the \emph{render()} function it is invoked the \emph{CarController()} function that checks the keyDown array and performs control actions on the vehicle.\\
		When the \emph{ESC} button is pressed the game is paused and all the timers, together with the \emph{render()} function, are stopped and can be resumed by pressing the left click button of the mouse. With the \emph{W, A, S, D} key buttons the user controls the direction and the speed of the vehicle. Moreover has been implemented the control to brake the vehicle (\emph{SPACE} button) and to reverse the vehicle if it become impossible to move the car (\emph{Q, E} buttons).\\

%1 page - N
\chapter{Animations}
	\par This chapter describes the animations realized in the project.
	\par As explained in the previous chapter the text movement in the index page is not a real animation, so we skip directly to the game page. The animated objects in the game are the pedestrians (NiceDude meshes) and the vehicle. Regarding to the vehicle animations they are handled by the \emph{cannon.js} library. By calling methods on the \emph{cannon.js vehicle} we it moves in the \emph{cannon.js world}, so the only thing we we did is to do overlap the \emph{three.js vehicle model} with the moving \emph{cannon.js vehicle}. With this process the car appears to move but we precise that the vehicle animations are not directly handled by us.
	\par What is fully created by our team are the NiceDude movements implemented in the \emph{animate()} method of the NiceDude object (see \emph{js/NiceDude.js}). 
	\section{NiceDude movements}
		\par The movement of a single NiceDude body can be distinguished in:
		\begin{itemize}
			\setlength\itemsep{0.25em}
			\item the movement it does around the building
			\item the movements of its parts (arms, legs and feet)
		\end{itemize}
		\par Starting from the movement around the building it is a quite simple translation along the axis of the NiceDude direction. The things get more complicated when we have to avoid the lamps and in this way rotate around the building. So what we did is to check at each call of the \emph{animate()} method if it is near to one of the four lamps of its square: if it is near the lamp we rotate the NiceDude object of 45\degree. By continuing to translate the object it will reach a position where is not anymore near to the lamp: when this happens we rotate again the object of 45\degree. In this way we have totally rotated the NiceDude object of 90 \degree and moreover we avoided the collision with the lamp.
		\par Dealing with the body parties animations they are realized by rotating the parties of a little constant so that by calling the \emph{animate()} method at each cycle of \emph{render()} they appear to move in a smooth way. When the specific part reaches the maximum angle value we invert the constant rotation value so that the parts rotate in the opposite direction. We keep to notice that the constant values to rotate the body parts are defined as instance variables of the NiceDude object: in this way each NiceDude object has its own variables and by changing them we do not modify the other values. In few words we solved a concurrency problem by spatially separating the values on which the critical section works.

%2 page - M
\chapter{Conclusion}
	\par In conclusion we can say that with this project, our group, has managed to achieve the goals previously set, we have managed to create a city with buildings, sidewalks and lamps. Our goal from the beginning has always been to create an interactive game in order to respect the required features, and most important to entertain the user.
	In this game the primary objective is pass through the largest number of pedestrians on the sidewalk before the time limit expire by driving a car. The user is responsible of driving the car with the classic commands of the most famous videogames. The presentation layer is simply and intuitive: when our car strikes one of the pedestrians it disappears, and at the same time our total score increses. \\
	\par Obviously like all the kind of projects, we found a lot of troubles with the handling two different kind of library(Three.js and Cannon.js) together, however we have fixed the most of the problems.  
	
	\section{How to test the project}
	    \par To test the project is very easy. It can be done through the github page or by downloading the entire folder of the project and run it offline. By following the second choice you should simulate a server on your machine, otherwise the most of the resources the game uses will not be found. We suggest to download the \emph{live-server} \cite{liveserver} application and run it by command line from the downloaded project folder. \\
	    \emph{(on command line.) \#\/projectfolder\/\$ live-server}
	\section{Bugs}
    	\par In this section we discuss about the bugs of the project that are not still resolved.
    	The most problematic bug is that of the collisions: sometimes the collisions between vehicle and city objects are not logged in the game. Since we implemented the collisions through the Cannon.js library, we rely on the \emph{collision} event that the physics engine automatically sends when two body collides. The bug consists of the missing creation of the collision event, and conseguently we can not receive the event collision. We specify that we do not have to send the event message, but it is the cannon.js library that has to do it. The only thing we can do is to receive the event message and implement an handler to do all the necessary operations for our project (remove the niceDude hitted and increment the total score).

\addcontentsline{toc}{part}{\refname}
\begin{thebibliography}{999}
	\bibitem{threejsdocs}
		THREE.JS Docs,
		\url{https://threejs.org/docs}
	\bibitem{cannonjsdocs}
		CANNON.JS Docs,
		\url{https://schteppe.github.io/cannon.js/docs}
	\bibitem{vehiclesite}
		Sketchfab.com,
		\url{https://sketchfab.com},
	\bibitem{texturesites}
		TextureLibs.com,
		\url{http://texturelib.com},
	\bibitem{backgrounsite}
		Emil Persson, aka Humus,
		\url{http://www.humus.name}
	\bibitem{jsevents}
		Javascript events,
		\url{https://www.w3schools.com/js/js_events.asp}
	\bibitem{liveserver}
		Application live-server,
		\url{https://www.npmjs.com/package/live-server}
	%\bibitem{codice}
		%cognome n., 
		%\emph{titolo, sottotitolo},
		%casa editrice,
		%anno.
\end{thebibliography}

\end{document}